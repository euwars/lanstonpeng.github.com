---
author: lanstonpeng
comments: true
date: 2011-09-12 15:27:15+00:00
layout: post
slug: xhr-%e4%b8%8a%e4%bc%a0%e6%96%87%e4%bb%b6%e6%96%b9%e6%b3%95%e5%b0%8f%e8%ae%ae
title: 小议 xhr 上传文件
wordpress_id: 592
categories:
- 未分类
tag:
- javascript
---

以前想用xhr上传文件,感觉方法不太那么优雅

最近在弄一个姑且命名为anyDragBox的小web应用，就是WYSIWYW类型...不多说了，在开发的过程中，遇到上传的问题了，跨域先不说，这里主要想讨论一下xhr上传文件的方法

**1.base64方案**
`
var reader=new FileReader()
reader.onloadend=function(e){
//var img=document.createElement("img")
//img.src=e.target.result
//document.body.appendChild(img)
xhr.onload=function(e){
document.write(xhr.responseText)
}
upload=xhr.upload
upload.addEventListener("progress",function(e){
console.log("loaded: "+e.loaded)
console.log("total: "+e.total)
},false)
xhr.open("POST","upload2.php");
xhr.setRequestHeader("Cache-Control", "no-cache");
xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
xhr.setRequestHeader("X-File-Name", file.name);
//xhr.setRequestHeader("X-File-Type",file.type)
xhr.send(e.target.result.match(/,(.*)$/)[1]) //注意 (1)
}
reader.readAsDataURL(file)
`

本地使用FileReader API的readAsDataURL获取文件的base64编码，发送给server，server再解码存储
<!-- more -->
_ 注意(1)_
FileReaer.readAsDataURL 获取的并非全是文件的base64编码的内容，其中夹杂着一些其它内容
data:[<MIME-type>][;charset=<encoding>][;base64],<data>
<data>
服务器方面，这里采用php

所以，为了获取其精确的内容，需要将前面内容去掉，留取<data>部分

`
$postdata = file_get_contents("php://input");
file_put_contents( $_SERVER['HTTP_X_FILE_NAME'], base64_decode($postdata));
`

在上面的js代码中，大家可以看到注释部分，我打算将拖拉的图片顺便显示在浏览器里面，但是这里存在一个问题，如果图片太大的话， base64会很多，浏览器解析非常慢，经常卡死甚至崩溃（我这里是Ubuntu10.10+chromium14）
我认为，如果想让用户得知自己所上传的图片的时候，采用本方案比较方便
** 2.二进制方案**

****
这种方式在client端所用的代码比较少
`
var files=e.dataTransfer.files
//这里我采用的拖拉的方式将文件上传，若是传统的点击选取文件，则使用e.target.files
var file=files[0]
var xhr=new XMLHttpRequest()
xhr.open("POST","upload.php");
xhr.onload=function(e){
document.write(xhr.responseText)
}
xhr.send(file);
`

在服务端方面，核心代码：
`
file_put_contents(
$this->path . $this->fileName,
file_get_contents("php://input")
);
`

采用本方案，高效简单，不用作过多的处理
网上有许多方案是模拟表单，代码都类似这样：
`
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary); // simulate a file MIME POST request.
xhr.setRequestHeader("Content-Length", fileSize);
var body = '';
body += "--" + boundary + "\r\n";
body += "Content-Disposition: form-data; name=\""+dropbox.getAttribute('name')+"\"; filename=\"" + fileName + "\"\r\n";
body += "Content-Type: "+fileType+"\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--\r\n";
xhr.sendAsBinary(body);`

其实，本质上也不过是跟二进制一样
