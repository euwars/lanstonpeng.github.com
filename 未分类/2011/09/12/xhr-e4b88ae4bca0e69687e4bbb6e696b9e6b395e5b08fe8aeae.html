<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>小议 xhr 上传文件</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Lanston Peng's idea</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>小议 xhr 上传文件</h2>
<p class="meta">12 Sep 2011</p>

<div class="post">
<p>以前想用xhr上传文件,感觉方法不太那么优雅</p>

<p>最近在弄一个姑且命名为anyDragBox的小web应用，就是WYSIWYW类型...不多说了，在开发的过程中，遇到上传的问题了，跨域先不说，这里主要想讨论一下xhr上传文件的方法</p>

<p><strong>1.base64方案</strong>
<code>
var reader=new FileReader()
reader.onloadend=function(e){
//var img=document.createElement(&quot;img&quot;)
//img.src=e.target.result
//document.body.appendChild(img)
xhr.onload=function(e){
document.write(xhr.responseText)
}
upload=xhr.upload
upload.addEventListener(&quot;progress&quot;,function(e){
console.log(&quot;loaded: &quot;+e.loaded)
console.log(&quot;total: &quot;+e.total)
},false)
xhr.open(&quot;POST&quot;,&quot;upload2.php&quot;);
xhr.setRequestHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);
xhr.setRequestHeader(&quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;);
xhr.setRequestHeader(&quot;X-File-Name&quot;, file.name);
//xhr.setRequestHeader(&quot;X-File-Type&quot;,file.type)
xhr.send(e.target.result.match(/,(.*)$/)[1]) //注意 (1)
}
reader.readAsDataURL(file)
</code></p>

<p>本地使用FileReader API的readAsDataURL获取文件的base64编码，发送给server，server再解码存储
&lt;!-- more --&gt;
_ 注意(1)_
FileReaer.readAsDataURL 获取的并非全是文件的base64编码的内容，其中夹杂着一些其它内容
data:[<MIME-type>][;charset=<encoding>][;base64],<data>
<data>
服务器方面，这里采用php</p>

<p>所以，为了获取其精确的内容，需要将前面内容去掉，留取<data>部分</p>

<p><code>
$postdata = file_get_contents(&quot;php://input&quot;);
file_put_contents( $_SERVER[&#39;HTTP_X_FILE_NAME&#39;], base64_decode($postdata));
</code></p>

<p>在上面的js代码中，大家可以看到注释部分，我打算将拖拉的图片顺便显示在浏览器里面，但是这里存在一个问题，如果图片太大的话， base64会很多，浏览器解析非常慢，经常卡死甚至崩溃（我这里是Ubuntu10.10+chromium14）
我认为，如果想让用户得知自己所上传的图片的时候，采用本方案比较方便
** 2.二进制方案**</p>

<hr>

<p>这种方式在client端所用的代码比较少
<code>
var files=e.dataTransfer.files
//这里我采用的拖拉的方式将文件上传，若是传统的点击选取文件，则使用e.target.files
var file=files[0]
var xhr=new XMLHttpRequest()
xhr.open(&quot;POST&quot;,&quot;upload.php&quot;);
xhr.onload=function(e){
document.write(xhr.responseText)
}
xhr.send(file);
</code></p>

<p>在服务端方面，核心代码：
<code>
file_put_contents(
$this-&gt;path . $this-&gt;fileName,
file_get_contents(&quot;php://input&quot;)
);
</code></p>

<p>采用本方案，高效简单，不用作过多的处理
网上有许多方案是模拟表单，代码都类似这样：
<code>
xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;multipart/form-data, boundary=&quot;+boundary); // simulate a file MIME POST request.
xhr.setRequestHeader(&quot;Content-Length&quot;, fileSize);
var body = &#39;&#39;;
body += &quot;--&quot; + boundary + &quot;\r\n&quot;;
body += &quot;Content-Disposition: form-data; name=\&quot;&quot;+dropbox.getAttribute(&#39;name&#39;)+&quot;\&quot;; filename=\&quot;&quot; + fileName + &quot;\&quot;\r\n&quot;;
body += &quot;Content-Type: &quot;+fileType+&quot;\r\n\r\n&quot;;
body += fileData + &quot;\r\n&quot;;
body += &quot;--&quot; + boundary + &quot;--\r\n&quot;;
xhr.sendAsBinary(body);</code></p>

<p>其实，本质上也不过是跟二进制一样</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                Lanston Peng<br />
                Life Hacker<br />
                lanstonpeng[AT]gmail.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="http://www.douban.com/people/lanstonpeng/">豆瓣</a><br />
                <a href="https://github.com/lanstonpeng">github.com/lanstonpeng</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
