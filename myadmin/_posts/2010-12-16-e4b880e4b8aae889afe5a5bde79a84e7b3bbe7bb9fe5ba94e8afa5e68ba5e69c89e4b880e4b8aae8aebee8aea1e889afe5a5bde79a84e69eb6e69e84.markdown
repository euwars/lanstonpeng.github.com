---
author: lanstonpeng
comments: true
date: 2010-12-16 08:04:25+00:00
layout: post
slug: '%e4%b8%80%e4%b8%aa%e8%89%af%e5%a5%bd%e7%9a%84%e7%b3%bb%e7%bb%9f%e5%ba%94%e8%af%a5%e6%8b%a5%e6%9c%89%e4%b8%80%e4%b8%aa%e8%ae%be%e8%ae%a1%e8%89%af%e5%a5%bd%e7%9a%84%e6%9e%b6%e6%9e%84'
title: 一个良好的系统应该拥有一个设计良好的架构
wordpress_id: 160
tag:
- .net
- idea
---

[](http://lantonspeng.blog.cd/files/2010/12/无标题221.png)


[ ](http://lantonspeng.blog.cd/files/2010/12/无标题221.png)

一个良好的系统应该拥有一个设计良好的架构，这样对以后的维护以及扩展带来极大的便利。

最近在了解一些有关设计原则的东西，而何为一个良好的设计，就我所学到的而言，我认为，在充分考虑该软件的将来，即在考虑软件的扩展性的问题上有一定的思考，又要在降低开发成本的问题上作出权衡，过度设计必然导致开发成本的上升，而未来是不可预知的，这只能视情况而定。

经典的原则经历过时间的考验，开发上必可作为指导，还是一个问题，盲目地套用是在做无用功，而真正的灵活运行还需在不断的实践中进行不断的思考。

<!-- more -->

下面是有关个人对一些原则的理解及看法

开放闭合原则:

![](http://lantonspeng.blog.cd/files/2010/12/无标题221.png-1024x570.png)

当我们对一个软件进行修改的时候，不应该对已有的功能模块进行修改，这里是对于普通情况，并且默认软件在该模块上设计是相对合理的，而是通过增加类的方式，扩展这种修改，而我们应该如何做到这种效果呢？我认为，模块功能应该依赖于抽象，公共接口不变，这里的接口不仅仅局限在interface上，举个自己乱写的例子：

假设我们登录FaceBook时要进行验证，可以通过Authentication1进行登录，该登录是基于密码什么的，

public class Authentication1:ISubject

{

FaceBook fb=null;

string pwd = "somecode";

public Authentication1(string pwd)

{

if (this.pwd == pwd)

fb = new FaceBook();

}

public void ResponseMessage()

{

if (fb == null)

{//dosomething

fb.Response();

}

else

{         //dosomeotherthing

}

}

}

这里只是演示，没什么具体设计可以的说的，

FaceBook是一个私有类，只有经过验证才能进行登录，

如果按照我们“传统的”登录方式，我们new一个Authentication1，然后进行相关操作，如果出现第二种登录方式，譬如指纹( ——|||  )，最差的一种方式是在Authentication1类中加个switch什么的，另外可以新建一个类，为Authentication2，具体方法有相应的算法什么的，这里不列出。然后我们在Client那里，有人可能会new一个Authentication2，然后进行相应的操作，

Authentication1 au1 = new Authentication1("zxv");

au1.ResponseMessage();

Authentication2 au2 = new Authentication2();

au2.ResponseMessage();

这样虽然我们的模块职责分配得比较单一，但是我们将工作交给客户端了，用户需要根据不同的验证方式进行登录，而且以后修改会比较繁琐，

一种方式是通过接口，这里我们实现ISubject接口，

ISubject isb = new Authentication1("pwd");

isb.ResponseMessage();

isb = new Authentication2();

isb.ResponseMessage();

当然这里的客户端也可以封装在类似一个工厂里面里面，根据不同的对象返回不同的实例，这样才更加体现用处。

我一开始对这种方式感觉作用不大，不就一个接口引用什么的，后来经过一定的思考，感觉作用还是挺大的：

首先，它定义了一组规范，每个实现必须遵循，这样，系统能做到比较规范，并且在以后的移植中带来很多便利，譬如我只改逻辑层，表现层完全不需要修改（当然，这要靠具体的实现），其次，接口是抽象的，假设我们的依赖于具体的实现，譬如像我们上面那样new不同的实例，这里很难看出，假设这里的验证方式有很多种呢，每一种要对应于一个类，这样，客户端方面要做的东西就很多了，他们根据自己需要验证的方式去实例化不同的类进行操作，这样显然不行。

于是，我们这里引入工厂，用户只是想怎样登录即可，不需要知道具体实现（这里说得可能比较模糊，打个比方，譬如我们在银行排队办理业务，我们需要知道我们要干什么，如存钱，贷款什么的，然后我们得自己走到相应的窗口，存钱窗口，贷款窗口什么的，但是，这里用户只需要告诉服务人员，我要存钱，服务人员就带你去存钱，你并不知道怎么走去，你只需告诉即可......）

占位的代码……(视觉污染……)

public class Factory

{   public string name;

public static ISubject  CreateObj(string n)

{        switch (n)

{            case "asdf": return new Authentication1("zxv");

//.....

}        return null;

}

}

于是，在client这边有：

ISubject myobj = Factory.CreateObj("call");

myobj = Factory.CreateObj("callanother");

这样，我们就将新建这样一个职责封装到一个类中，以后能很方便修改，而客户端仅仅需要少少的修改

其实，这里不仅仅是一个原则的体现，原则之间相互融合才能达到更高的层面，迫于时间有限……
