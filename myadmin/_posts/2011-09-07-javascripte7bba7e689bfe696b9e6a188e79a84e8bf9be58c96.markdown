---
author: lanstonpeng
comments: true
date: 2011-09-07 11:36:56+00:00
layout: post
slug: javascript%e7%bb%a7%e6%89%bf%e6%96%b9%e6%a1%88%e7%9a%84%e8%bf%9b%e5%8c%96
title: javascript继承方案的进化
wordpress_id: 586
categories:
- 未分类
tag:
- javascript
---

在javascript中，继承是一个颇为热门的话题

    
    var Human=function(name,age){
        this.name=name;
        this.age=age;
    }
    Human.prototype.sayName=function(){ console.log(this.name); }


然后，我们让一个对象继承Human

    
    var lanston=function(name,age){
        Human.call(this,name,age);
        this.isVeryBad=true;
    }
    lanston.prototype=new Human();
    var check=new lanston("lanstonpeng",21);
    check.name=="lanstonpeng";
    check.sayName(); //lanstonpeng


虽然这种方式比较常见，但是却存在一点效率问题：
因为其两次调用了Human
在这种情况下，实际上在 lanston 中与lanston.prototype 中都存在name,age
一个name，age是在new Human()时创建的
另一个是在Human.call时创建的

通过翻阅了一些资料，发现了一种比较好的办法，就是取消 new Human() 这一步，用一下方法来替代
<!-- more -->

    
    function beget(obj){
        var f=function(){};
        f.prototype=obj;
        return new f();
    }
    function extend(Super,Sub){
       Sub.prototype=beget(Super.prototype);
    }


稍微分析一下代码，beget函数其实就是新建一个对象，起原型指向我们指定的那个需要被继承的父对象（即代码中的obj),
我相信看过The good parts 的朋友肯定对这个函数名有印象
至于我们一开始需要

    
    lanston.prototype=new Human()


无非是想继承**Human**的方法，但是带来的弊端就是多余的属性，这里就是name跟age了,
我们只需要在**lanston**上需要name跟age，不需要在其prototype上面拥有这些属性，我们要的
仅仅是方法而已
至于extend方法就是为了解决这个问题的，beget函数在上面已经说明了，其它的也不难理解
所以，用同样的方法，将上面的代码改改

    
    extend(Human,lanston)




ref-->
[Classical Inheritance in JavaScript](http://www.crockford.com/javascript/inheritance.html)
[Prototypal Inheritance in JavaScript](http://javascript.crockford.com/prototypal.html)
